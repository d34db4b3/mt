use std::{
    collections::BTreeSet,
    fmt::{self, Display, Write},
    iter, ops,
};

#[derive(PartialEq, Debug, Clone, PartialOrd, Eq, Ord)]
struct Variable(String);

impl fmt::Display for Variable {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(&self.0)
    }
}

#[derive(PartialEq, Debug, Clone, PartialOrd, Eq, Ord)]
struct XorExpr(BTreeSet<Variable>);
impl XorExpr {
    fn new<S: ToString>(var: S) -> XorExpr {
        XorExpr(iter::once(Variable(var.to_string())).collect())
    }
}

impl fmt::Display for XorExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for (i, x) in self.0.iter().enumerate() {
            if i != 0 {
                f.write_char('^')?;
            }
            x.fmt(f)?;
        }
        Ok(())
    }
}

impl ops::BitXor for XorExpr {
    type Output = XorExpr;

    fn bitxor(self, rhs: Self) -> Self::Output {
        // a^a=0
        let mut s = self.0;
        for v in rhs.0 {
            if !s.remove(&v) {
                s.insert(v);
            }
        }
        XorExpr(s)
    }
}

#[derive(Debug, Clone)]
enum XorExprBit {
    Expr(XorExpr),
    Value(bool),
}

impl fmt::Display for XorExprBit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            XorExprBit::Expr(x) => fmt::Debug::fmt(&x.0, f),
            XorExprBit::Value(v) => {
                if *v {
                    1.fmt(f)
                } else {
                    0.fmt(f)
                }
            }
        }
    }
}

impl ops::BitXor for XorExprBit {
    type Output = XorExprBit;

    fn bitxor(self, rhs: Self) -> Self::Output {
        match (self, rhs) {
            (XorExprBit::Value(s), XorExprBit::Value(r)) => XorExprBit::Value(s ^ r),
            (XorExprBit::Expr(s), XorExprBit::Expr(r)) => XorExprBit::Expr(s ^ r),
            (XorExprBit::Expr(x), XorExprBit::Value(v))
            | (XorExprBit::Value(v), XorExprBit::Expr(x)) => {
                if v {
                    panic!("x^1 is not supported")
                } else {
                    XorExprBit::Expr(x)
                }
            }
        }
    }
}

#[derive(Debug, Clone)]
struct XorExpr32([XorExprBit; 32]);

impl XorExpr32 {
    fn var<S: Display>(s: S) -> Self {
        XorExpr32::gen(|i| XorExprBit::Expr(XorExpr::new(format!("{s}_{i}"))))
    }
    fn gen<F: Fn(usize) -> XorExprBit>(op: F) -> Self {
        XorExpr32([
            op(0),
            op(1),
            op(2),
            op(3),
            op(4),
            op(5),
            op(6),
            op(7),
            op(8),
            op(9),
            op(10),
            op(11),
            op(12),
            op(13),
            op(14),
            op(15),
            op(16),
            op(17),
            op(18),
            op(19),
            op(20),
            op(21),
            op(22),
            op(23),
            op(24),
            op(25),
            op(26),
            op(27),
            op(28),
            op(29),
            op(30),
            op(31),
        ])
    }
    fn apply_all_bits_with<F: Fn(XorExprBit, XorExprBit) -> XorExprBit>(
        self,
        rhs: Self,
        op: F,
    ) -> Self {
        let mut s = self.0.into_iter();
        let mut r = rhs.0.into_iter();
        XorExpr32(
            iter::repeat_with(|| op(s.next().unwrap(), r.next().unwrap()))
                .take(32)
                .collect::<Vec<_>>()
                .try_into()
                .unwrap(),
        )
    }
}

impl ops::BitXor for XorExpr32 {
    type Output = XorExpr32;

    fn bitxor(self, rhs: Self) -> Self::Output {
        self.apply_all_bits_with(rhs, |a, b| a ^ b)
    }
}

impl fmt::Display for XorExpr32 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        struct Shim<T>(T);
        impl<T: fmt::Display> fmt::Debug for Shim<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "{}", self.0)
            }
        }
        let mut l = f.debug_list();
        for x in &self.0 {
            l.entry(&Shim(x));
        }
        l.finish()
    }
}

const N: usize = 624;
const M: usize = 397;

const A: u32 = 0x9908B0DF;

const SEQ: [&[u8; 32]; 80] = [
    b"\x61\x17\x47\x72\xe2\xe9\x0b\xad\x86\x5c\x09\x67\x30\x61\x97\x15\x0e\x88\x68\xa2\xd3\x42\xd8\xc0\x4f\x39\xfd\xcf\xe8\xa6\xaa\x24",
    b"\x17\x69\x1f\xeb\x21\xc1\x0a\xc3\x16\xfa\x91\x8a\x6f\xf0\x16\x59\xea\x4c\x23\x41\x23\xc9\x66\x3a\x60\xb8\xfd\x02\xad\xd0\xf1\x4f",
    b"\xab\x70\x2c\x8e\xb0\x4c\xa7\xfc\x09\xa5\x1d\x03\xd7\x4c\xfb\xd6\x04\xa7\xb6\x6f\x70\xb5\xb9\xc7\x61\x2e\xbf\xee\x8d\xd5\x9b\x78",
    b"\xfa\x0f\xc7\xf1\x06\x38\x89\x5f\xd0\xfc\x72\x4b\x57\x3c\x1d\x6e\x81\x71\x03\x1c\x4a\xa5\xa6\xcb\x9e\x9c\x06\x63\x25\x54\x6e\xf4",
    b"\xca\x9e\x1a\x4a\xdc\x46\x37\x6d\xec\x29\x8e\xce\x73\x9d\x7a\xa0\x3e\xf3\xb9\xfa\xf4\xbc\xb5\xa8\x63\xdc\x7f\xb0\x5d\x15\x40\x55",
    b"\xe1\xfb\xd5\x8b\x37\xaf\xcf\x6a\x8c\x79\xc7\x22\x5c\x73\xc5\x07\x40\x21\xb1\x8d\x38\xd4\x98\x94\xdc\xc3\xe8\x11\x07\x81\x21\xf3",
    b"\x33\x7e\x88\x08\x47\x4a\x89\x41\xb1\xe0\xad\x26\x4a\xae\xa0\xcb\x6c\xe9\x87\xdb\x74\xa9\x04\xf0\xac\x95\x48\x57\xd1\x41\xfe\x2e",
    b"\xab\x28\x4e\x5e\x2d\xb8\x40\xe0\xd0\xab\x6f\x2c\xc5\xda\x23\xdd\x89\xc2\x74\x4f\x2f\x70\x2a\x65\x04\xee\xfa\x50\x04\xdb\xcb\x25",
    b"\x8a\x01\x12\x12\xac\x55\x8a\xb3\x57\x92\x2c\x58\x88\x4c\x78\xd4\x0e\x39\x8b\x39\x5c\xbf\xbc\x6d\xde\x1b\x8c\xd2\x04\xd3\x8b\xc6",
    b"\x70\x5c\xde\x20\x21\x53\xe7\xab\x79\xb9\xe9\x3c\x94\xce\x2b\xfb\x2a\xe0\x4d\xd9\xbc\x1d\x9f\xe9\x20\x30\xfb\x9d\x49\x02\xfa\xe4",
    b"\x03\xdf\x87\x2b\xa5\x0d\x34\xe0\x67\xe0\x3b\x06\x58\x69\x9d\xc4\x24\x00\xb0\x40\x21\xa4\xfa\x4d\x14\xcb\x1b\x7e\x5e\xbf\x65\x36",
    b"\x7b\xad\x07\x2c\x19\x51\x45\xab\x9a\x22\x9d\x2b\x8c\xff\x39\x7e\x47\xd2\x6c\x1d\x3f\x6b\x7c\xd2\x58\xa5\x15\xbb\xfd\x93\xb5\x9f",
    b"\x38\xfd\x5c\x1b\x70\xb9\x15\x1f\x1e\x55\x8a\xdf\x10\x37\x0b\x2d\x79\xbc\x02\xae\xc5\xce\xf0\x98\xa7\x57\x05\x19\x5f\x10\x8d\x34",
    b"\x02\x78\x91\xf3\xd8\xa1\xd5\x0b\x71\x39\xbf\x92\xce\x55\x19\xa9\xf5\xb7\xfb\x83\x1c\x13\x6c\x91\x81\x0f\x06\x5c\x6a\x04\x2c\x7a",
    b"\xae\x4a\x35\x39\xc9\x9d\xe7\x97\x3b\x44\xda\xf6\x68\xbe\x59\xfe\x92\x13\x2c\x54\xae\x3a\xbd\xa6\x9d\x8d\xe2\xed\xad\x49\x1d\xb8",
    b"\x82\x13\xba\x37\x8e\xe8\xea\xa0\x50\x57\x3b\xfb\xd9\x21\xc4\x5b\xd8\xb3\x02\x2d\xf2\x4e\x37\x4a\xae\xbd\x4d\x36\x60\x7e\x1a\x90",
    b"\xbf\x4a\x19\x2b\xac\x6a\xfd\x56\x7b\x86\x1c\xd2\x39\xf4\x0c\x07\xe7\x4c\x56\xc8\xad\xd2\x9a\x1d\xb7\x91\x5e\x04\x11\x66\xf1\xdb",
    b"\x89\xe5\xca\x4f\xcf\xd5\x1b\x55\xe7\xa2\xec\x62\x11\x60\xd3\x0b\x47\xfd\x52\x59\x46\x29\x7b\x5d\x06\xfb\x3e\xdd\x0c\x95\x0a\x14",
    b"\x99\x1f\x2f\x60\xeb\x1d\x91\x88\x07\x5f\xfd\xbb\xf5\xdc\x1a\x41\xd4\x34\x76\x76\xc7\x3c\x77\xed\xbe\x85\xb0\x73\xe1\x3c\x0e\xff",
    b"\x12\x48\xf5\x42\xec\x61\x7a\xca\x56\x10\x65\xaf\x1b\xfc\x64\x90\x68\xf8\xb9\xb2\xec\xa5\x2a\x0f\x0e\x47\xfc\xbb\xa7\xe9\x2c\x1e",
    b"\xc4\x14\x47\xc5\x2e\xfa\xa4\xad\x70\x5c\x7f\xb4\x57\x27\xf6\x98\x64\x0e\x46\xcc\xea\xb3\x4d\x69\xcc\x18\xf5\x2a\xcc\xf5\x0f\x67",
    b"\x4b\x64\x72\xe9\xfb\x7b\xd3\x77\xa3\x95\x58\x09\x4d\x39\x9a\x92\x53\xae\x81\x70\xed\x6c\x01\x13\xbe\x64\xbd\xfa\xd9\x56\x10\x98",
    b"\xef\x73\xc0\x77\x4b\xf5\x4a\x42\x0b\x94\xf3\x86\x66\xc8\x19\x53\x85\x57\x2c\x51\x7c\xdb\xd4\xc4\xcc\x95\x3f\xd4\x12\x15\x52\xf7",
    b"\x98\x5e\xa7\xc0\x36\x7e\x20\xe4\x9a\xd0\x56\xb6\x4b\x36\x08\xa2\x05\x12\xfb\xf8\x5d\x0d\x6d\xa2\x63\xcb\xfc\x12\xe5\xbe\x11\x08",
    b"\x4a\x98\x52\x61\x40\x36\xd7\x2d\xe8\x16\xe6\x95\x76\xbc\x2b\x9c\x92\x60\xef\x69\x81\xfe\x79\xf8\xef\xe5\xed\x14\x33\x82\xd4\xed",
    b"\x1a\x07\x4a\x08\x81\xf0\xed\xe6\x62\x28\x75\x32\xa1\x3b\x37\xee\xef\x6e\x15\xc7\x68\x42\x9b\x82\x24\x85\x83\xd0\x54\xd4\xa1\x53",
    b"\x7d\x30\x14\x22\x30\x2c\x69\x81\x11\x5d\xcb\x5c\xbc\xaf\xcb\x7f\xf1\xc5\x09\xbb\x38\xb0\x5f\x55\xe8\x69\x6e\xc7\xba\x70\xc8\x64",
    b"\xdd\xe3\xa7\xc9\x57\x3f\x61\x05\x7d\x54\xea\x99\xc1\x0b\xb7\x1a\x45\xab\xc7\x2d\xeb\xa2\xf4\xf1\xed\xe9\x77\xe1\xe2\xb7\x57\xe4",
    b"\x20\x86\x49\x90\x59\x21\x65\x9e\x17\xb5\x1d\xbd\x65\xbe\xfc\x95\x26\x52\xad\x7c\x3d\xc2\x4a\x54\x0c\x18\x07\xbc\x8f\x8f\xbb\x5e",
    b"\x02\x2b\xc7\x9d\x44\xb7\x1c\xda\xf1\xd1\xec\x6e\x9d\xf6\x50\xad\xe3\x62\xda\x95\x70\x87\x22\xda\xa9\x7c\xf1\x50\x28\x58\x3d\xf2",
    b"\xf7\xcd\x09\x66\x2d\xfb\x73\x59\x79\x25\x52\x9c\x3d\x59\xd3\x18\x0e\x58\x3e\xda\x73\xab\x85\xf3\xe1\x5a\x26\xec\x72\xa2\x95\x08",
    b"\xbd\x0c\xbc\x3d\xec\x2d\xef\xe9\x37\x7b\xb5\xc1\x9b\x84\xc2\x68\xb8\x95\x5e\x4d\xcb\xfd\x61\x63\xec\x68\x09\x9c\x43\x8c\xfc\xc7",
    b"\x9f\x56\xaf\x18\xd6\xf8\x4f\xea\x11\xc5\xcb\x68\x66\xd6\x25\x40\x15\xf5\xd6\xcf\x44\x1c\x96\x50\x8b\x45\xc1\xdf\x2e\x51\x53\x78",
    b"\xc2\x56\xce\xcd\x98\xc0\xe1\xce\xf3\x21\xc9\xcc\xc0\x60\xd8\x80\x39\x54\x05\x69\x77\x76\xe4\xf4\x7c\xdf\x96\xa2\x46\x11\xa1\x73",
    b"\x36\x70\x05\x7d\x8e\x0a\xa7\x06\xd0\xc5\x7e\x5e\x2b\x06\xce\xc5\x64\xf9\xab\x64\x8a\xab\x29\xc7\xd7\xa2\xcc\x04\x3d\x25\x2a\x75",
    b"\x34\xff\x10\x5b\xd2\x89\xf6\x73\x86\x44\x70\x5c\x4d\xb0\x31\x01\x4f\x35\x5f\x2f\x65\xd7\x15\x4a\xbe\xe6\x48\x6b\x35\xbc\xcb\x08",
    b"\x4d\x6b\x92\xc1\x6f\xbf\x57\x31\xd0\x46\x25\x88\x5c\x05\xc4\x3d\x6c\xd1\xc4\xf2\x1c\xdc\xec\xaa\xdb\x9c\xe8\x07\xe3\x3a\xf4\xa5",
    b"\xa1\x10\x33\xbd\x74\x38\xc8\x29\xcb\x66\xcb\x17\xf2\xb7\xe1\xf5\xd7\xf0\xf1\xfa\x4f\x1e\x9f\x38\x4e\x6b\x63\xe2\x6f\x9b\x9d\xab",
    b"\x23\x50\x95\x8f\x9c\x0b\x8b\x1e\x1d\xb8\xd1\xc9\x85\xce\xab\x50\x76\x68\x70\x77\x6a\xcb\xc1\xd6\xee\xdd\x6f\x0d\x1b\x76\xd6\x29",
    b"\x29\x5a\x09\x2f\xa5\x42\x72\xba\x56\x07\xa7\xcd\x3c\xf3\x83\x5d\x6b\xb2\xc4\xcf\x44\x99\x78\x7c\xa7\x92\xc8\x07\xbc\xc2\x1a\x7c",
    b"\x37\x42\x5b\xfb\x53\x8e\x07\x65\x58\xdd\x55\x47\x01\x36\xd5\xbf\x79\xad\x70\x1f\x7b\x93\x9f\x98\x0d\xf4\xc1\x03\x70\x42\xe6\x7f",
    b"\x21\x5a\xee\x34\xe9\x54\xd3\xc4\x11\xd1\x39\x87\xac\x58\x23\x1f\x1c\x0e\x1c\xd2\x91\xce\x0f\x2c\xd1\x23\x3d\xfd\x20\xd4\x23\x75",
    b"\xe5\x52\x9d\x75\x90\xd0\x17\xf4\xf3\xbc\xc6\xb4\xc9\x45\x8a\x36\x5c\x07\xef\x17\x21\x7c\xe8\xe3\x06\xd2\xcc\xab\x09\xb6\x9b\xc7",
    b"\x41\xbc\x1a\xc3\xd6\xe8\xa4\xb2\x82\x96\x67\x18\x68\x64\xa2\xbf\xd2\xaf\x5a\x5a\xad\xec\xc6\xaf\x7a\xc1\x35\x2f\xb1\x95\xca\x4c",
    b"\x8a\xa6\xd5\x54\x2b\x13\xb2\xb5\x3c\xb1\x96\x49\x2d\x70\x3b\x4c\x29\xe6\x4d\xeb\x74\xc0\x43\xfb\x44\xb7\x54\x4b\x69\xe4\x84\x85",
    b"\xe9\x76\xe1\xde\x0b\x81\x51\x56\xdf\xf6\xe9\x6e\xa9\x37\x75\xfd\x92\x6f\x2c\x49\x06\xd0\xef\x8d\x9a\x37\xb9\x32\xeb\x72\xbf\x69",
    b"\xf8\xce\xeb\xf3\xcb\x9f\x2f\xe1\xb7\xf5\xb1\x65\x4a\xd4\x93\x3d\xb5\xfb\x58\x40\x0b\xd3\x4c\xec\x15\xd2\x01\xdc\xc6\x1c\x4b\xd7",
    b"\x33\x2b\x11\xdc\x95\x2b\xa9\xb6\x78\xa1\xc8\x20\x94\x47\x98\xb2\x16\x61\xa1\x18\xd3\x68\xe6\xed\x3b\xb4\xaa\xd7\xfa\xb3\xd3\x33",
    b"\x43\xd8\xe3\xc9\x13\xf7\x25\x7d\x14\xf8\xc3\xfb\x8d\x21\x0f\x0b\x8b\x90\x0c\x64\x19\x6f\xf9\xe6\x97\x38\xf2\xbd\xda\x85\x1c\x73",
    b"\x11\x6b\x4e\xea\x40\x8d\xe7\x21\x2f\x85\x65\xbc\xbb\x42\x01\x19\x34\x35\xd7\x8d\xe8\xa2\x82\x68\xa4\x9c\x85\xf4\xa4\xe9\xe2\xf6",
    b"\x82\xb0\xb1\xf4\xf9\x46\x2c\xf6\x64\xf6\x07\x51\x80\xe2\x9b\xac\x7e\x98\x33\x74\x5b\x1b\x0e\xfc\x06\xa2\x28\xb6\x22\xfc\x3b\x53",
    b"\x00\x21\x04\x0f\x20\x8b\x7a\x49\x3d\x14\xda\x84\x95\x7b\xc8\x0c\xe2\x4c\x6f\xc9\xc7\xa3\x00\xec\x74\xb0\x1e\x89\x33\xb2\xcc\x35",
    b"\x9d\xce\xe5\xa1\x82\x21\x8c\xce\xd1\xec\x5a\xf3\x82\x42\x40\x44\xf2\x2a\x9c\x06\xaf\x04\xd9\x05\x99\x55\xdc\xec\x08\x19\xf9\xd9",
    b"\x05\x7c\xe4\xd3\x4d\xfb\xbd\xd8\x17\x6a\xea\x46\x19\x7f\x78\xef\x22\x99\x97\x9c\x96\xec\xdb\x60\xbe\x00\xa9\x16\x81\x4c\xdd\x8c",
    b"\x46\x52\xd9\xed\x3f\x6d\x2f\xc1\xe9\x69\x11\x50\xed\x05\xb6\xa1\x27\xfc\xc1\x88\xb4\xc8\x36\x06\x0c\xdf\xb7\xb8\xb1\x19\xa2\xe1",
    b"\x18\xcb\xf0\xa5\xb5\xf4\xbc\xf7\x85\x9e\x37\xf2\x6c\x8f\xdb\xdd\x49\x7b\x5b\x74\x9a\x84\xf1\xf3\xce\xa6\x1a\xee\x0b\x90\x0a\x98",
    b"\x68\x24\x92\x9f\xc7\x03\xb6\x24\xe8\x98\x82\x99\x7e\x60\xfe\x6e\x9b\x9c\x4f\x56\xec\xf7\x3b\x70\xd0\x32\x58\xb8\xf8\xe5\xe1\xf8",
    b"\x11\x70\x86\x0f\xd8\x52\x83\x8f\x50\xa6\x8b\xf6\xd9\x84\x88\x3c\x4d\x24\x24\xb5\xa1\x3a\x09\xf7\xef\xed\xc5\x23\x82\x5e\x18\xd0",
    b"\x88\x96\xbf\x46\x05\x95\xbc\xd2\x5a\x28\x0d\xef\xd1\x5d\xb3\x4d\x53\xb3\xd8\xb3\x39\x05\x40\xe7\x8c\x1f\x0f\xaa\x7f\x21\xfb\xb2",
    b"\x1a\x7e\x01\x2b\x7a\x12\xc6\x0a\xd2\x74\x57\x12\x58\x44\xd2\x9c\xf3\xbd\x73\xf8\xe3\xa2\xc9\xf1\x18\x84\x5f\x01\x66\x5f\x1c\xec",
    b"\x0e\x89\xa0\xb1\x93\xc4\xc2\x7c\xf8\xfd\xf7\xf2\x79\xab\x88\x95\x83\xce\x14\x26\xd8\x6e\xc6\xff\x4e\xf4\xf7\xff\x78\x6c\xce\x90",
    b"\x9f\x37\xa8\xcb\x52\x86\x62\xb2\xf7\x06\xc1\xe3\x3b\x85\xd7\x6b\x16\xde\x03\x05\x38\x67\xd6\x7b\x8c\xc6\x69\xc7\xe5\xfe\x00\x4c",
    b"\x77\xb5\x4f\x03\x17\xbc\xdc\xd1\x1c\x27\xe4\x53\xa4\x9f\xbb\xf5\xd2\x12\xec\x23\x60\x42\x70\x77\xf6\x28\x7a\x2f\x22\x9e\xe5\x31",
    b"\x76\x80\x95\xf9\x92\xfd\x89\xa2\x08\xb4\x10\x5c\xaf\xc3\xe2\x8e\xf7\x8c\x59\xc1\xaa\x0f\x4b\x1b\x41\x7c\x9e\x0d\xb7\x4a\x68\x28",
    b"\xa3\x82\x0f\x9a\x90\x7c\x7f\x85\xe2\x2f\x01\xf5\xfe\x1c\x57\xe1\xe4\x96\x9b\xe4\x69\x72\x96\x2c\x5b\x75\xf2\x14\x4d\xce\xd7\x65",
    b"\x99\xc1\x6f\x31\x5d\xbe\x13\xd9\x66\x19\xd9\xeb\xdf\xbe\x16\x87\xb1\x0f\x5d\x4c\xa6\x57\xaf\x6b\x8b\x7c\x6e\xcd\xca\x64\x3f\x0c",
    b"\x1f\xb9\x7a\xf6\xfb\x12\x44\xa0\xba\x65\xf3\x24\x19\x9c\x55\xa0\xb2\x7b\x31\x35\xfd\x91\xe7\x85\xa8\x4e\x92\xcd\x72\xb3\x09\x5d",
    b"\xb1\x92\xa2\x39\x31\xaf\x97\xc1\x4f\x57\xf2\xf4\x9d\x40\xc3\x78\x2d\x60\x89\x09\x29\x58\xf7\xc7\x4c\x38\xea\x3a\xa6\x13\x6c\x18",
    b"\xd3\x52\xbc\xd3\xbe\xff\xbb\xc4\x68\xae\x75\x2a\xbc\xb4\xe4\xd3\x0d\x32\xa6\x95\x3d\x24\x45\xeb\x1e\xd8\xae\x0a\xe9\x32\x2b\xad",
    b"\x14\xf6\x4f\xc6\x53\x27\xc7\x91\xc0\x61\x50\x48\x0a\x71\xa6\xd0\xf1\x52\x56\xd7\x56\x09\xbc\x19\xb5\x6b\x22\x9b\xa5\x12\x68\x63",
    b"\x75\x0f\x5e\x01\xcd\x3b\xbe\xcd\x01\xa9\xad\xc3\x2b\x7a\x6c\x94\x6b\x1f\x6b\xfd\xb0\xac\x58\xf9\xda\x5e\xf3\xa1\x4c\x46\x00\x0e",
    b"\x80\xf3\x92\x00\x93\xfd\x5d\x2a\xd6\x8d\x41\x3a\x7f\x70\x08\xeb\xac\xaf\x34\x0d\xb8\x22\xdd\xaa\xaf\xbb\xc8\xa6\x3b\xf9\x2d\xff",
    b"\x30\x45\x89\x42\x0f\x49\x21\x7d\x0a\x09\x18\xc5\x9c\x37\xdd\x78\x73\x70\x7f\xde\x53\xcd\xa9\x8a\xd9\xcc\x2c\xb3\x5b\xd6\xd8\x7b",
    b"\x77\x9f\x41\x58\x92\x10\x7f\xea\x7b\x01\x15\x83\x3a\x79\x73\xf5\xe7\x24\x2f\xb6\x5f\x2a\x65\x3c\xf3\x5c\x35\x39\xb7\xfb\xd2\x7e",
    b"\xce\xbe\x54\x9d\x49\xce\xa3\x5a\x49\x64\xa1\x40\x6e\xff\xe1\x1d\x26\x99\xbb\xd3\x03\xb1\xa2\x06\x97\x40\xd0\x45\xfb\x57\x03\xce",
    b"\x0e\x03\x23\x22\x7f\x04\x95\x33\x89\xb2\xd2\x02\x5b\x12\x91\x8e\x36\xc6\xb1\x7a\x23\x3c\x63\x5a\x6e\x5b\xa3\x16\x83\x9a\x16\x68",
    b"\x3a\x1e\xb5\x8e\x03\xc1\x1d\xd5\x21\x5c\xbe\xaa\xae\xda\x4d\x68\x38\x4c\xf1\xc6\x65\x9b\x90\xa3\x47\x60\x98\x5e\x40\x61\x88\xec",
    b"\x0c\x53\x07\xa6\x1f\x5f\x02\x55\xe0\x1e\x6a\xd5\xde\x09\x78\xd7\x9c\xa6\xed\x0d\x9c\x66\x44\xb5\x52\x3f\x0f\xff\x99\xde\xe1\xd5",
    b"\x31\x64\xe0\x99\x7d\x92\x92\x9a\x48\x53\x67\x08\x35\xf2\x79\x61\x99\xef\xc8\x15\x9d\xa2\xf6\x48\x41\xaf\x28\x6a\x39\x53\x78\x86",
    b"\xf9\x0c\xf0\x42\x32\x4c\x64\x1c\x9a\xb5\xa8\x48\xf1\x5b\x51\xb3\x1c\x0d\xe3\x40\xec\xeb\x09\x6e\xee\xfa\x69\xc9\xf8\x6b\xc1\x28",
];

struct SeqGen(usize);
impl Iterator for SeqGen {
    type Item = bool;

    fn next(&mut self) -> Option<Self::Item> {
        let chunk = self.0 / 256;
        let byte = (self.0 % 256) / 8;
        let bit = self.0 % 8;
        self.0 += 1;
        SEQ.get(chunk)
            .and_then(|chunk| chunk.get(byte))
            .map(|&byte| (byte >> (7 - bit)) & 1 == 1)
    }
}

struct MT19937Breaker {
    mt: [XorExpr32; N],
    i: usize,
    system: Vec<(XorExpr, bool)>,
}
impl MT19937Breaker {
    fn new() -> Self {
        Self {
            mt: (0..N)
                .map(|n| XorExpr32::var(format_args!("mt_{n}")))
                .collect::<Vec<_>>()
                .try_into()
                .unwrap(),
            i: 0,
            system: Vec::new(),
        }
    }
    fn twist(&mut self) {
        for i in 0..N {
            let x_0 = self.mt[(i + 1) % N].0[0].clone();
            let x_a = XorExpr32([
                self.mt[(i + 1) % N].0[1].clone(),
                self.mt[(i + 1) % N].0[2].clone(),
                self.mt[(i + 1) % N].0[3].clone(),
                self.mt[(i + 1) % N].0[4].clone(),
                self.mt[(i + 1) % N].0[5].clone(),
                self.mt[(i + 1) % N].0[6].clone(),
                self.mt[(i + 1) % N].0[7].clone(),
                self.mt[(i + 1) % N].0[8].clone(),
                self.mt[(i + 1) % N].0[9].clone(),
                self.mt[(i + 1) % N].0[10].clone(),
                self.mt[(i + 1) % N].0[11].clone(),
                self.mt[(i + 1) % N].0[12].clone(),
                self.mt[(i + 1) % N].0[13].clone(),
                self.mt[(i + 1) % N].0[14].clone(),
                self.mt[(i + 1) % N].0[15].clone(),
                self.mt[(i + 1) % N].0[16].clone(),
                self.mt[(i + 1) % N].0[17].clone(),
                self.mt[(i + 1) % N].0[18].clone(),
                self.mt[(i + 1) % N].0[19].clone(),
                self.mt[(i + 1) % N].0[20].clone(),
                self.mt[(i + 1) % N].0[21].clone(),
                self.mt[(i + 1) % N].0[22].clone(),
                self.mt[(i + 1) % N].0[23].clone(),
                self.mt[(i + 1) % N].0[24].clone(),
                self.mt[(i + 1) % N].0[25].clone(),
                self.mt[(i + 1) % N].0[26].clone(),
                self.mt[(i + 1) % N].0[27].clone(),
                self.mt[(i + 1) % N].0[28].clone(),
                self.mt[(i + 1) % N].0[29].clone(),
                self.mt[(i + 1) % N].0[30].clone(),
                self.mt[i].0[31].clone(),
                XorExprBit::Value(false),
            ]) ^ XorExpr32::gen(|i| {
                if A >> i & 1 == 1 {
                    x_0.clone()
                } else {
                    XorExprBit::Value(false)
                }
            });
            self.mt[i] = self.mt[(i + M) % N].clone() ^ x_a;
        }
    }
    fn feedbit(&mut self, b: bool) {
        if self.i >= N {
            self.twist();
            self.i = 0;
        }

        let y = self.mt[self.i].0[31].clone()
            ^ self.mt[self.i].0[24].clone()
            ^ self.mt[self.i].0[16].clone()
            ^ self.mt[self.i].0[27].clone();
        self.i += 1;
        let XorExprBit::Expr(x) = y else {panic!("expected expr")};
        self.system.push((x, b));
    }
}

fn main() {
    let mut breaker = MT19937Breaker::new();
    let vars = (0..N)
        .map(|n| (0..32).map(move |i| Variable(format!("mt_{n}_{i}"))))
        .flatten()
        .collect::<BTreeSet<_>>();
    let mut mat = Vec::with_capacity(vars.len());

    println!("feeding..");
    for b in SeqGen(0).take(256 * 78) {
        breaker.feedbit(b);
        let (e, b) = breaker.system.last().unwrap();

        // matrix form
        let row = vars
            .iter()
            .map(|x| e.0.get(&x).is_some())
            .chain(iter::once(*b))
            .collect::<Vec<_>>();
        mat.push(row);
    }
    println!("systom size {}", breaker.system.len());

    println!("{:?}", vars);
    for row in &mat {
        for b in row {
            print!("{}", if *b { 1 } else { 0 });
        }
        println!()
    }
    println!("solving...");

    // # Creating a function to perform gaussian elimination on the given matrix mat
    // def gauss_elem(mat):
    //     num = len(mat)

    //     for i in range(0, num):
    //         # Searching the maximum value of a particular column
    //         max_el = abs(mat[i][i])
    //         # Row having the element of maximum value
    //         max_row = i
    //         for k in range(i + 1, num):
    //             if abs(mat[k][i]) > max_el:
    //                 max_el = abs(mat[k][i])
    //                 max_row = k

    //         # Swapping the maximum row with the current row
    //         for k in range(i, n + 1):
    //             temp = mat[max_row][k]
    //             mat[max_row][k] = mat[i][k]
    //             mat[i][k] = temp

    //         # Chaning the value of the rows below the current row to 0
    //         for k in range(i + 1, n):
    //             curr = -mat[k][i] / mat[i][i]
    //             for j in range(i, n + 1):
    //                 if i == j:
    //                     mat[k][j] = 0
    //                 else:
    //                     mat[k][j] += curr * mat[i][j]

    //     # Solving the equation Ax = b for the created upper triangular matrix mat
    //     l = [0 for i in range(n)]
    //     for j in range(n - 1, -1, -1):
    //         l[j] = mat[j][n] / mat[j][j]
    //         for k in range(j - 1, -1, -1):
    //             mat[k][n] -= mat[k][j] * l[j]
    //     return l
    let n = mat.len();
    for i in 0..n {
        // Searching the maximum value of a particular column
        // i_max is the index of first occurence of 1 in column h
        let i_max = (i..n)
            .map(|k| mat[k][i])
            .position(|i| i)
            .unwrap_or_else(|| panic!("no 1 found in col {i}"));
        // Swapping the maximum row with the current row
        mat.swap(i, i_max);
        // Chaning the value of the rows below the current row to 0
        for k in i + 1..n {
            let curr = match (mat[k][i], mat[i][i]) {
                (_, false) => panic!("div by 0"),
                (r, true) => r,
            };
            for j in i..n + 1 {
                mat[k][j] = if i == j {
                    false
                } else {
                    mat[k][j] ^ (curr && mat[i][j])
                }
            }
        }
    }

    // let mut h = 0;
    // let mut k = 0;
    // while h < mat.len() && k < mat[k].len() {
    //     // i_max is the index of first occurence of 1
    //     let i_max = (h..mat.len())
    //         .map(|i| mat[i][k])
    //         .position(|i| i)
    //         .unwrap_or_else(|| panic!("no 1 found in col {k}"));
    //     if !mat[i_max][k] {
    //         k += 1;
    //     } else {
    //         mat.swap(h, i_max);
    //         for i in h + 1..mat.len() {
    //             let f = match (mat[i][k], mat[h][k]) {
    //                 (_, false) => panic!("div by 0"),
    //                 (r, true) => r,
    //             };
    //             mat[i][k] = false;
    //             for j in k + 1..mat[h].len() {
    //                 // mat[i][j] -= mat[h][j] * f [mod 2]
    //                 mat[i][j] ^= mat[h][j] && f;
    //             }
    //         }
    //         h += 1;
    //         k += 1;
    //     }
    // }
    println!("done");

    for (i, row) in mat.iter().enumerate() {
        for (j, v) in row.iter().enumerate() {
            // v should be true only when i == j
            assert!((i == j) == *v)
        }
    }
    // for (eq, r) in breaker.system {
    //     println!("{eq}={r}");
    // }
}
